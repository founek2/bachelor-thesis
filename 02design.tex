
\chapter{Analýza a návrh}
Tato kapitola se zabývá analýzou problémů v oblasti IOT Platformy a návrhem architektury řešení.

\section{Analýza procesů}
Analýza procesů pomáhá pochopit, zlepšit a třídy procesy v dané doméně. U jednotlivých procesů jsou popsány jejich vstupy, výstupy a jednotlivé kroky.

\subsection{Interakce se zařízeními}
Mějměm zařízení světlo, které se nachází ve dvou stavech vypnuto/zapnuto. Uživatel s takovým zařízením potřebuji interagovat, aby ho dokázal přepnout do jiného stavu. Toho může docílit pomocí ovládáním hlasem nebo pomocí aplikace (fyzický vypínač vynecháme). V obou případech musí Platforma zajistit přepnutí zařízení do požadovaného stavu odesláním příslušného požadavku. Pro složitější zařízení (s více stavy) platí naprosto stejný postup.

\subsection{Vizualizace data}
Chytrá zařízení mohou generovat velké množství dat z různých typů senzorů (teplota, tlak, množství CO2 v ovzduší) a tyto data je potřeba uchovávat. Průběh jednotlivých údajů v čase lze následně využít např. pro optimalizaci vytápění kvůli úspoře nákladů. Systémové rozhraní by mělo také data vizualizovat a nabídnout uživateli na ně náhled, aby si mohl vytvářet vlastní analýzy.

\subsection{Zabezpečení}
Mezi chytrá zařízení dnes patří mimo jiné pohybová čidla, zámky dveří, senzory neoprávněného vniknutí a detektory požáru. Jedná se o zabezpečovací prvky u kterých je potřeba zajistit vysokou spolehlivost a v případě přístupových prvků jako zámky na dvěří také vysokou bezpečnos. Platforma v případě detekování neočekávaného pohybu nebo násilného vniknutí upozorní na tuto skutečnost uživatele.


\subsection{Automatizace}
Platforma umožňuje definovat různé scénaře v reakci na různé události (např. změna teploty, detekce pohybu). Tímto způsobem lze automatizovat všední akce, nemuset na ně myslet a plně se tak můžeme věnovat věcem, které vyžadují naší pozornost. Napříkald při přichodu domů bude automaticky detekována naše přítomnost, zapnuto topení a celé domácnost nastavena dle osobních preferencí. Trávník je automaticky zavlažován při nedostatku vláhy a všechna světla vypnuta, jakmile odešel poslední člen domácnosti spát.



\section{Analýza požadavků} %https://moodle-vyuka.cvut.cz/pluginfile.php/388192/mod_resource/content/3/02.prednaska.pdf 
Tato sekce se zabývá vymezetím hranic systému pomocí sběru funkčních a nefunkčních požadavů. Funkční definují funkce systému, které systém musí implementovat. Nefunkční určují omezení kladená na systém a mají zásadní dopad na návrh architektury.

\subsection{Funkční požadavky}

\paragraph{F1 Registrace uživatelů}
- systém bude umožnovat libovolnému uživateli registraci. Každému registrovanému uživateli bude zřízen na server účet, který bude uchovávat jeho registrační údaje - jméno, přijmení, uživatelské jméno, heslo, email. Součástí registračního formuláře bude zaškrtávátko \uv{Automaticky přihlásit}, které bude ve výchozím stavu aktivní. Pokud ho uživatel nezruší, tak po úspěšné registraci bude uživatel automaticky přihlášen do systému.

\paragraph{F2 Obnovení zapomenutého hesla}
- součástí přihlašovacího formuláře bude odkaz na stránku pro obnovení zapomenutého hesla, kde bude uživatel dotázán na emailovou adresu, kterou použil při registraci. Po zadání, pokud daná emailová adresa je součástí některého uživatelské účtu, bude na ni odeslán email s odkazem pro obnovu hesla. Na tomto odkazu bude uživatel vyzván k zadání nového hesla.

\paragraph{F3 Přidání zařízení}
- přihlášenému uživateli se ve správě zařízení objeví možnost přidat ke svému účtu nové zařízení, pokud bude systémem detekované. Pro přidání bude uživatel vyzván k zadání umístění daného zařízení.

\paragraph{F4 Oprávnění na úrovni zařízení}
- na úrovni zařízení půjde nastavovat oprávnění pro jednotlivé uživatele. Toto oprávnění se bude skládat z těchto 3 úrovní:
\begin{itemize}
    \item \textbf{Read} - uživatel bude moci si pouze zobrazit veškeré údaje o zařízení
    \item \textbf{Control} - stejné oprávnění jako \uv{read} + navíc zařízení může ovládat
    \item \textbf{Write} - uživatel může editovat veškeré informace o zařízení (včetně oprávnění)
\end{itemize}

\paragraph{F6 Typy prvků}
- systém bude podporovat následující typy prvků a umožňí uživateli v rozhraní příslušné interakce.
\begin{itemize}
    \item \textbf{Senzor} - základní prvek, odesílá hodnoty do systému
    \item \textbf{Přepínač} - může se nacházet ve stavu zapnut/vypnut. Uživatel bude moci poslat příkaz ke změně stavu.
    \item \textbf{RGB světlo} - tento prvek má 3 vlastnosti: zapnuto/vypnuto, jas, barva. Uživatel může měnit všechny.
\end{itemize}

\paragraph{F5 Vizualizace dat}
- rozhraní umožní sledování dat ze všech typů prvků v reálném čase. Dále umožní vizualizaci historických naměřených údajů ze senzory, jejíchž výstup je číselná hodnota. Vizualizace bude realizována v podobě grafu vývoje hodnoty za určitý čas.

\paragraph{F7 Editace zařízení}
- jednotlivá zařízení bude možno přejmenovat a změnit jejich umístění.

\paragraph{F8 Notifikace}
- uživatel si bude moci nastavit Push notifikace pro jednotlivé prvky, které ho upozorní na změnu stavu. U senzorů si bude moci nastavit hranici, notifikace se pak odešle pokud ji hodnota překročí resp. sníží pod ni.

\paragraph{F8 Validace}
- veškerá formulářová pole budou interaktivně validována na straně uživatele v rozhraní a následně znovu na straně serveru. Interaktivní validací jsou myšleny tyto scénáře při průchodu formuláře:
\begin{itemize}
    \item Zadání hodnoty a vykliknutí z pole - bude provedena validace a v případě nevalidního vstupu, bude uživatel upozorněn.
    \item Editace hodnoty v poli - validace bude provedena po každé změně (stisknutí klávesy), uživatel bude opět upozorněn v případě nevalidní hodnoty.
\end{itemize}


\subsection{Nefunkční požadavky}

\paragraph{N1 Systém spustinelný na Linux systému}
- systém bude možno provozovat na Linuxovém serveru (Debian) a také na platformě Raspberry Pi (Raspbian).

\paragraph{N2 Responzivní webové rozhraní}
- aplikace bude nabízet responzivní uživatelské rozhraní přizpůsobené pro zobrazení na mobilních zařízeních i stolních počítačích. Uživatelské rozhraní bude kompatibilní s prohlížeči Mozilla Firefox verze 80, Chrome verze 80 a Safari na iOS. Dále bude implementovat tzv. PWA (Progresivní webová aplikace) - bude využívat cache pro statické soubory, pro rychlé načítání a na zařízení Android půjde v aplikaci chrome přidat na plochu a následně vypadat jako nativní aplikace.

\paragraph{N3 Rozhraní realizováno jako SPA}
- SPA (Single page application) je webová aplikace, která utilizuje JavaScript, aby při interakci v rámci aplikace se nemusela celá stránka načítat, ale pouze chytře překresluje potřebné části. Výsledkem je mnohem přijemnější uživatelský zážitek, než při nutnosti překleslovat celou stránku po kliknutí na odkaz.

\paragraph{N4 Koncová zařízení na platformě ESP8266}
- pro jednotlivá zařízení bude použit čip ESP8266 od firmy Espressif jako mikrokontroler, který bude komunikovat po sítí prostřednictvím Wifi sítě.

\paragraph{N5 Výkonnostní požadavky}
- systém bude stabilní a zvládne obsluhovat stovku zařízení, kde každé bude odesílat změnu stavu s periodicitou 30 vteřin. Při tomto dlouhodobém zatížení nebude docházet k pádům systému ani k výraznému zpoždění komunikace (RESTful požadavky pod 500 ms).

\paragraph{N6 Konfigurace systému} %env promněné
- veškerá konfigurace (týkající se externích služeb/komunikace) jako jméno a heslo do databáze, číslo portu pro komunikaci atd. bude konfigurovatelné pomocí promněných prostředí (env variables). Detailní popis promněných bude obsažen v instalační příručce.



\section{Popis domény}
TODO text
Popis jednotlivých enntit:
\begin{itemize}
    \item \textbf{User (Uživatel)} - osoba interagující se systémem
    \item \textbf{Device (Zařízení)} - fyzické zařízení komunikující se systémem, umožňující ovládání Věcí a odesílání dat
    \item \textbf{Thing (Věc)} - např. světlo, meteostanice nebo zásuvka
    \item \textbf{Property (Vlastnost)} - určitá vlastnost Věci (např. pro zásuvku je \uv{vypínač} - vypnuto/zapnuto, pro meteostanici \uv{teplota} - naměřená hodnota)
    \item \textbf{Location (Umístění)} - umístění dané zařízení, specifikována budova a pokoj
    \item \textbf{State (Stav)} - v jakém aktuálním stavu se určitá Věc nachází
\end{itemize}


\section{Analýza případů užití}
Tato kapitola popisuje identifikované případy užití, ve kterých figurují následující aktéři:
\begin{itemize}
    \item User - aktér představující autentizovaného uživatele webového rozhraní.
    \item User ROLE\_ADMIN - aktér představující autentizovaného uživatele s právý kompletní správy systému.
\end{itemize}

\subsection{UC1 - Registrace uživatele}
Neautentizovaný uživatel vyplní registrační formulář obsahující jméno, přijmení, uživatelské jméno, heslo a email. Validace dat bude prováděna dle [F8]. Při zpracování požadavku na serveru bude zajištěna unikátnost uživatelského jména a emailu napříč databází. Uživatel bude informován o úspěchu/neúspěchu akce. Po úspěšném vytvoření bude automaticky přihlášen, pokud nezrušil ve formuláři zaškrtávátku \uv{Automaticky přihlásit}, a bude mu odeslán uvítací email na zadanoou emailovou adresu.

\subsection{UC2 - Přidání nového zařízení}
\label{UC:UC2}
Uživatel ve správě zařízení bude mít sekci \uv{Přidat zařízení}, kde se zobrazí všechna nově detekovaná zařízení, která ještě nemá přidaná. Následně při kliknutí na tlačítko přidat se zobrazí jednoduchý formulář pro zadání umístění a názvu zařízení - bude předvyplněn název, který ohlásilo zařízení. Uživatel formulář potvrdí, systém následně vytvoří dané zařízení, přidá uživateli k němu oprávnění a ná stránce \uv{Ovládání} už bude uživatel moci sledovat aktuální stav Věcí a případně je i ovládat (pokud to umožňují).

\subsection{UC3 - Zobrazení teploty}
Na stránce \uv{Ovládání} bude zobrazeny jednolivé místnosti ve formě Widgetu, ve kterém budou aktuální údaje ze senzorů v dané místnosti. Při rozkliknutí místnosti budou zobrazeny všechny senzory a Věci. Po kliknutí na senzor bude uživateli zobrazena informace o stáří aktuální hodnoty a zobrazen graf vizualizující průběh hodnoty v čase za posledních 24 h.

\subsection{UC4 - Rosvícení světla}
Na stránce \uv{Ovládání} po rozkliknutí místnosti obsahující Věc pro ovládání světla \uv{přepínač} bude zobrazen prvek umožnující uživateli jeho změnit stav. Po kliknutí bude odeslán požadavek pro změnu stavu na server, který ho odešle danému zařízení. Po potvrzení od zařízení, že ke změně opravdu došlo bude ze serveru odeslána tato informace webové aplikaci.

\subsection{UC5 - Editace zařízení}
Uživatel na stránce \uv{Správa zařízení} bude mít zobrazena všechna zařízení, ke kterým má oprávnění pro editaci. Rozhraní umožní pomocí formuláře editaci názvu zařízení, umístění a změnu oprávnění pro jednotlivé uživatele. Dále může zařízení smazat.

\subsection{UC6 - Správa uživatelů}
Uživatel s rolí \uv{admin} může přistoupit na stránku \uv{Správa uživatelů}, kde se mu zobrazí seznam všech registrovaných uživatelů. Jednotlivé uživatele může smazat a pomocí formuláře editovat jejich osobní údaje včetně hesla.

\subsection{UC7 - Device discovery}
Zařízení pokud není ještě není spárované s Platformou, tak při zapnutí odešle status=\uv{init}, následně začne ohlašovat, které Věci má a jejich Vlastnosti. Po jejich odeslání pošle status=\uv{ready} a příslušnému uživateli, ke kterému se zařízení hlásí se zobrazí v rozhraní viz. \hyperref[UC:UC2]{UC2}. Po jeho přidání uživatelem Platforma odešle zařízení API klíč, které si ho uloží a přihlásí se pomocí toho klíče.

\subsection{UC8 - Změna stavu Vlastnosti}
Při požadavku na změnu stavu \uv{Vlastnosti} odešle Platforma požadavek na dané zařízení, které provede změnu a odešlě potvrzovací zprávu, že ke změně úspěšně došlo. V případě nevalidního požadavku, zařízení žádné potvrzení neposílá.


\section{Vybrané technologie}

\subsection{Komunikační protokol}   %https://ieeexplore.ieee.org/abstract/document/8079928
Komunikační protokolů je velké množství a přímo závisí na výběru přenosného média. Při použití specializovaných sítí jako LoRa nebo Zigbee, nemáme moc velkou flexibilitu ve výběru. Zařízení podporující tyto specializované sítě jsou také poměrně drahá, ale umožňují běh na baterii. Zatímco využití WiFi sítě nám dává obrovskou flexibilitu ve výběru protokolů a zařízení podporující připojení k Wifi nebyli nikdo více cenově dostupné jako dnes. Primárně z finančních nároků a možnosti využití stávající WiFi infrastruktury v domácnosti jsem se rozhodl pro WiFi jako bezdrátové médium. Současně díky přímé podpoře IP protokolu nebudu muset vytvářet bridge mezi serverem a sítí se zařízenímí jako např. při použití Bluethooth či LoRa.

%https://www.educba.com/mqtt-vs-websocket/
Z protokolů pro komunikaci je dnes neojoblíběnější HTTP, který ale nativně nepodporuje obousměrnou komunikaci, kdy zařízení může poslat zprávu serveru a stejně tak server zprávu zařízení, kterou pro ovládání zařízení budu potřebovat. Z obousměrných protokolů se velmi osvědčil WebSocket, který lze velmi snadno kombinovat s HTTP. Jedná se o protokol postavený nad TCP, který naváže spojení a obě strany mohou posílat zprávy. Je to velice hezké řešení pro posílání zpráv, ale neumožňuje nativně systematickou filtraci nebo odběr pouze určitých zpráv a nepočítá s během na nespolhlivých zařízeních. Proto přímo pro IOT vznikl otevřený síťový protokol MQTT jehož specifikaci vydává OASIS[??]. Využívá asynchroní pattern publish-subsribe a byl speciálně navržen pro potřeby běhu na jednoduchých embeded zařízení s minimálním datovým tokem.

MQTT se vyvýjí již od roku 1999 a momentálně nejpoužívanější verzí je 3.1.1 pro kterou vznikla specifikace v roce 2014. Protokol primárně běží nad TCP/IP, ale lze využít v jakékoliv síti kde je zaručeno správné pořadí dat, beztrátovost a obousměrnost komunikace. Protokol definuje 2 typy entit: \uv{message broker} a klient. MQTT broker je server, který přijímá všechny zprávy od připojených klientů a přeposílá je správným příjemncům (klientům). MQTT klient je jakékoliv zařízení (od embeded až po server), které komunikuje s brokerem přes síť.

Posílaná data jsou zde hierarchicky rozdělena do tzv. topiců (česky témat). Topic je textový řetězec o maximální délce 65536 Bytů s oddělovačem "/" - ukázka "/house/bedroom/light". Pokud klient chce odeslat (publish) data, tak pošle zprávu brokeru s daty a topicem do kterého zpráva patří. Broker potom zprávu odešle všem klientům, kteří jsou přihlášení k odběru (subscrib) z daného topicu. O odběr se klient musí přihlásit a buď přímo specifikuje plný název topicu nebo částečný s použitím wildcard. MQTT počítá s případnou nespolehlivostí ať koncových zařízení nebo sítě a proto umožňuje klientovy při přihlášení definovat \uv{Last Will and Testament} (LWT), jedná se udání tématu a zprávy, do kterého se odešla v případě nesprávně odpojeného klienta. Takto lze notifikovat ostatní, že došlo je ztráně spojení s daným klientem.

Broker podporuje 3 třídy QoS (Quality of service), kterou lze specifikovat pro každou zprávu jednotlivě v závisloti na její důležitosti, jsou seřazeny vzestupně dle náročnosti na systém (overhead):
\begin{itemize}
    \item \textbf{0 - Maximálně jednou} - zpráva je odeslána pouze jednou a klient ani broker nijak napotvrzují její přjetí
    \item \textbf{1 - Alespoň jednou} - zpráva je odeslaná několikanásobně, dokud není potvrzené její přijetí
    \item \textbf{2 - Právě jednou} - odesílatel a příjemnce navazují dvoucestný hand-shake, aby bylo zaručeno přijmutí zprávy právě jednou
\end{itemize}
% TODO přeložit wildcard, overhead + pěkný obrázek client - broker - client pub/sub s komunikací

\subsection{Výhody jednotného jazyku}
Využití jednotného jazyka pro vývoj Backendu a Frontendu přináší obrovskou výhodu v podobě možnosti sdílet nejenom definice pro objekty, ale i přímo části kódu. Toto je velmi vhodné například pro jednotné validace formulářů, různé datové transformace a sdílení aplikační logiky pro frontend \uv{optimistické aktualizace} (aktuální trend, nečekat na potvrzení požadavku ze serveru, ale rozhraní aktualizivat, jako by požadavek byl úspěšný a pouze v případě neúspěchu zobrazit stav ze serveru). Dále jednotný jazyk umožňuje programátorům při vývoji v případě potřeby pohodlně pracovat na obou částech aplikace aniž by se museli učit nový jazyk.

\paragraph{TypeScript} je superset JavaScriptu, který navíc přidává komplexní typový systém a rozhodl jsem se ho využít jako hlavní programovací jazyk pro frontend i backend. Jedná se o OpenSource jazyk vyvýjený společností Microsoft, který jeho vznikem chtěl usnadnit přechod C\# a .NET vývojářum k webovým aplikacím. Mnoho lidí z JavaScript komunity považuje TypeScript jako kontroverzní počin, protože přidává složitost k velmi elegantnímu jazyku a zvyšuje časovou náročnost vývoje. Já jsem dlouho dobu tento názor také zastával, ale v posledních letech při práci na větších projektech a díky zkušeností z jiných jazyků (včetně striktně typových jako C++ a Java), jsem změnil svůj názor ve prospěch TypeScriptu. Souhlasím, že na první pohled prodlužuje dobu vývoje. Programátor musí psát věci navíc oproti čistému JavaScriptu, ale v dlouhodobém životním cyklu se tato práce \uv{na víc} mnohonásobně vrátí. A to v podobě statické kontroly typů, která minimalizuje riziko pádu aplikace a umožňuje  lepší statickou analýzu kódu, a dále jako největší přínost pro mne jako programátora TypeScript přináší funkční \uv{našeptávání} ve vývojovém prostředí, které pro JavaScriptu i přes veškeré snahy bohužel funguje ve velmi omezené míře.

\subsection{Backend}    %https://nodejs.org/en/docs/
%spousta jazyků, pro koncepsi asynchroních messages MQTT a Websocket se hodí NodeJS
Vzhledem k povaze MQTT, který je koncepčně založený na asynchroních zprávách jsem si zvolil technologii NodeJS, která je postavené na asynchroní event-driven architektuře. NodeJS je prostředí pro běh JavaScriptu na straně serveru, kterému se v posledních letech dostává velké pozornosti kvůli jeho oblíbenosti mezi vývojáři, je extrémně přívětivý k začínajícím programátorům a má pozvolnou křivkou učení. Díky své architektuře nabízí velice elegantní přístup pro zpracování akcí, kde se musí dlouho čekat na výsledek jako primárně u síťové komunikace. V tradičním jazyce jako Java se taková akce musí řešit pracným vyvtvořením nového vlákna, které čeká na výsledek a následným zpracováním. V NodeJS je programátor od této problematiky odstíněn a může se tak plně věnovat tvorbě aplikační logiky aniž by měl znalosti a zkušenosti s více vláknovým programováním.

%https://vegibit.com/what-is-nodejs/ 
%modeulscount.com - down currently 
\paragraph{NodeJS} má pravděpodobně aktuálně největší a nejaktivější komunitu ze všech jazyků. Pro správu knihoven používá balíčkovací systém npm (jsou i jiné alternativy) ze kterého se stal největší ekosystém na světě, který je zastřešený neziskovou společností "npm, Inc." provozující centrální repozitář se všemi dostupnými moduly pro NodeJS. Díky sve centralizaci je velmi jednoduchý na používání, ale v posledních letech kdy se NodeJS zpopularizoval a nyní se obecně JavaScript řadí mezí nejoblíbenější jazyky, se ukázala centralizace jako poměrně nešťastné řešení, kvůli vysokým nákladům na provoz infrastruktury. Pro představu velikosti ekosystému: npm v roce 2020 obsahoval 1 200 000 modulů a druhý největší systém RubyGems "pouhých" 350 000. Všechny moduly jsou k dispozici zcela zdarma a díky takto aktivní komunitě lidí, kteří dávají k dispozici své knihovny ostatním, je vysoce pravděpodobné, že pokud chceme řešit nějaký problém, tak na něj již existuje knihovna.

%https://expressjs.com/
\paragraph{ExpressJS} je velmi minimalistický webový framework (první verze v roce 2010), který je do dnes velmi oblíbený a v mnohém ovlivnil vývoj většiny frameworků. Jeho největší výhoda je vysoká flexibilita. Nabízí pouze základní definici způsobu pracování s HTTP požadavky a možnost registrovat tzv. middleware - software, který rozšiřuje funkcionalitu. Veškerá funkcionalita je dodávána pomocí middlewarů, které jsou k dispozici jako moduly. Vývojář si tedy může výsledný server poskládat přesně dle svých představ, kterých existují desítky vytvořených přímo od autorů a další stovky od komunity.

\paragraph{MongoDB} je OpenSource dokumentová NoSQL databáze umožňující horizontální škálování. Oproti klasické SQL databázi používá dynamické schéma, díky kterému lze aplikaci mnohem dynamičtěji vyvíjet na rozdíl od SQL databází, kde i malá změna tabulkového schéma v mnoha případech znamená velmi komplikovanou migraci dat. MongoDB používá pro uchovávání dokumentů podobný JSONu (MongoDB nazývá formát BSON), což se velmi snadno kombinuje s jazykem JavaScript, který JSON používá pro nativní objekty.

\paragraph{Mongoose} je knihovna pro NodeJS, která vytváří nad MongoDB objektovou abstrakci a spoustu dalších užitečných funkcí jako validace a type cast. Základním prvkem je definování schéma pro jednotlivé dokumenty, což může vypadat jako návrat do striktního schématu u SQL databází, ale zde je schéma definované pouze na úrovni Mongoose, tedy mnohem flexibilnější a méně striktní. MongoDB sice nabízí oficiální knihovnu pro přístup do databáze, ale preferuji Mongoose, protože díky definici schémat mám obecně větší kontrolu nad daty, která se dostanou do databáze.

\paragraph{AgendaJS} je knihovna na perzistentní plánování úkolů (jobs) pro NodeJS. Podporuje zpracování/plánování/perzistenci úkolů a jejich opětovné zpracování v případě chyby. Tato knihovna bude primárně využita pro zajištění odeslání emailů a pro spouštění případných plánovaných akcí. Proč v souvislosti s odesláním emailů? Jejich zpracování je závislé na třetí straně - emailovém serveru, který nemusí být vždy dostupný. Pokud systém bude mět odeslat email, tak tímto způsobem bude zajištěno, že i v případě selhání bude email opětovně odeslán jakmile bude možné.

\paragraph{Socket.IO} umožňuje navázíní obousměrného spojení s kompatibilním klientem. Je založený na vlastním protokolu využívající HTTP spojení nebo WebSocket a vyznačuje se vysokou spolehlivostí a rychlostí umožňující real-time komunikaci. Jedná se o velice populární a časem ověřené řešení, které zajišťuje kompatibilitu i s prohlížeči nepodporující technologii WebSocket.


\subsection{Frontend}
% React + Redux
Prvním světoznámím průkopníkem ve světě JavaScriptu pro tvorbu uživatelského rozhraní byla knihovna jQuery, která existuje do dnes, ale spíše se již považuje za přežitek doby. Dnes máme velké množství Frameworků a knihoven pro tvorbu frontendu, ať pro tvorbu na straně serveru nebo přímo na straně uživatele v JavaScriptu. Trend dnešní doby je přesouvat generování rozhraní na stranu uživatele, jak kvůli snížení výkonostních nároků na server, tak spíše kvůli lepší odezvě a uživatelskému zážitků. Mezi nejznámější JavaScriptové frameworky patří bezpochyby Angular, Vue.js, Svelte a nesmíme zapomenout na React, který je sice knihovna, ale řadí se na stejnou úroveň. Já jsem si zvolil jako hlavní prostředek React, právě proto že se jedná o knihovnu. Framework se vyznačuje tím, že vynucuje určité problémy řešit jistým způsobem bez možnosti volby. Má to své výhody a nevýhody a do větších týmu bych rozhodně volil raději Framework. Tento projekt ale budu vytvářet primárně sám a mám velice rád flexibilitu a možnost volby. V začátcích to bývá časově náročnější, ale vidím v tom obrovskou možnost osobního růstu, protože při každé volbě musím hodnoti výhody/nevýhody a nakonec retrospektivně vidím následky svých rozhodnutí. Mimo to je React vytvářet společností Facebook a používán největšími technologickými světa, takže je jistá jeho dlouhodobá podpora a od roku 2013, kdy byla vydána první verze je hojně odzkoušený a ověřený.

%https://reactjs.org/tutorial/tutorial.html#what-is-react
\paragraph{React} je deklarativní, efektivní a flexibilní JavaScriptová knihovna pro tvorbu uživatelského rozhraní. Kód dělí do malých ižolovaných částí nazvaných "komponenta", které se skládání do sebe a mohou tvořit komplexní uživatelská rozhraní. Pro vysoký výkon využívá techniku virtuálního DOM - nejprve si vytvoří virtuální strom podoby rozhraní v paměti, který následně porovná s aktuální podobou vykreslenou v prohlížeči a zmanipuluje pouze ty části které se od posledního vykreslení změnily. Díky tomu je velice efektivní a dokáže vykreslovat komplexní stránky s obrovským množstvím dat.

%https://redux.js.org/introduction/getting-started
\paragraph{Redux} je knihovna pro state management. Ve větších aplikací je potřeba mít úložiště pro tzv. state (reprezentace momentálního stavu aplikace). Čím větší aplikace je, tím více dat je potřeba uchovávat a proto je nutno využít nějaké systematické řešení. React dlouho žádné takové nenabízel a bylo nutno využívat jiné knihovny jako např. Flux nebo Redux. V nejnovějších verzí již takové řešení nabízí, ale já přeferuji mít větší izolaci mezi vizuálnímí komponenty a statem, navíc Redux je odzkoušený časem a nabízí mnohem komplexnější řešení.

\section{Návrh uživatelského rozhraní}